## **项目规范 (v5.0 Final: The AI-Native Architecture Guide)**

### **序言：规范不是限制，而是人与 AI 协作的桥梁**

在 AI 辅助编程时代，代码的“优雅”不再是隐藏复杂性，而是**将复杂性结构化、显式化、可推理化**。

AI 模型本质上是无状态的函数逼近器，它擅长处理显式的输入输出和无副作用的逻辑流。然而，传统的编程范式充满了隐式的状态和分散的副作用，这对于 AI 而言如同黑盒，导致其生成的代码充满了“临时补丁”，难以维护和信任。

本规范的建立，旨在解决这一核心矛盾。我们不追求让 AI 理解人类模糊的“优雅”，而是**为 AI 重构“优雅”的定义**。

我们通过一套严格的分层架构，将复杂性显式化，为人类和 AI 提供一个共同的、清晰的协作基础。这套规范，是为人与 AI 共同建造可靠系统的**最小共识**，是 AI 从“代码补丁工”成长为“工程协作者”的基石。

---

### **第一部分：宏观架构与原则**

#### **1.1 四层架构模型：AI 友好的协作基础**

我们所有的代码都必须严格遵循`Kernel ← Module ← Service ← Main`的四层架构模型。每一层职责明确，依赖单向，共同构建一个 AI 友好、人类可维护的系统。

**依赖方向戒律：`Kernel ← Module ← Service ← Main`**
> **仅允许从右向左的单向依赖。严禁任何反向依赖（如 Module 导入 Service）或跨层依赖（如 Module 导入 Main）。**

*   **Kernel 层 (`src/kernels/`)**: **通用能力的“已解决问题”**。与业务完全解耦的、可跨项目复用的通用逻辑集合。
*   **Module 层 (`src/modules/`)**: **无状态的业务函数工具箱**。由 Kernel 函数组合而成的、完全被动、无状态、无副作用的业务函数集合。
*   **Service 层 (`src/services/`)**: **状态的唯一合法持有者**。应用中唯一允许持有和管理运行时状态的层级，负责编排 Kernel 和 Module。
*   **Main 层 (`src/main.ts`)**: **副作用的边界与系统组装点**。应用的启动入口和最终的副作用执行边界。

#### **1.2 通用设计原则**

以下原则是支撑四层架构得以实现的基础，它们必须被贯穿于所有层级的代码编写中。

*   **函数化 (Functional)**
    *   **纯函数优先**: 在 `Kernel` 和 `Module` 层，**必须**只使用纯函数。在 `Service` 层，也应优先将可计算的逻辑提取到纯函数中。
    *   **数据不可变性**: **严禁**直接修改任何函数参数、对象或数组。**必须**通过创建副本返回新的数据结构。
    *   **组合优于继承**: **严禁**使用 `class` 的 `extends` 继承。

*   **无状态 (Stateless by Default)**
    *   **禁止全局状态**: **严禁**定义和使用任何形式的全局可变状态。
    *   **显式依赖传递**: 所有函数和组件的依赖**必须**作为参数显式传入。
    *   **`Service` 是状态的唯一归宿**: `Kernel` 和 `Module` **必须**保持完全无状态。

*   **严格类型定义 (Strictly Typed)**
    *   **必须启用所有 `strict` 选项**: `tsconfig.json` 中**必须**启用所有 `strict` 模式。
    *   **原则上禁止 `any`**: **严禁**在新代码中使用 `any` 类型。应优先使用 `unknown` 并配合类型守卫。
    *   **强制定义公共接口**: 所有从 `index.ts` 导出的函数、类型、接口**必须**拥有完整且明确的 TypeScript 类型定义和 JSDoc 注释。

#### **1.3 技术选型原则**

*   **禁止重复造轮子**: 在实现任何通用功能（如日志、HTTP客户端、事件发射器）之前，**必须**优先寻找并评估现成的、社区认可的、维护良好的稳定库。

---

### **第二部分：层级内部结构与编码规范**

每个 `Kernel`、`Module` 或 `Service` 都是一个功能内聚的“单元”，其内部文件组织必须遵循以下规范。

#### **2.1 单元的通用文件组织**

一个功能单元由多个单一职责的文件构成，并通过`index.ts`对外暴露其公共接口。

*   **目录结构示例 (`src/modules/user-validator/`)**:
    ```
    user-validator/
    ├── utils/          # (可选) 存放内部使用的、更细粒度的纯函数
    │   ├── email.ts
    │   └── password.ts
    ├── index.ts        # 唯一的公共出口，组装并导出最终的函数
    └── types.ts        # 定义该单元的专属类型
    ```
*   **核心原则**:
    *   **单一职责文件**: 每个 `.ts` 文件应只关注一个单一的职责。复杂的单元**应该**被拆分为多个内部文件。
    *   **`index.ts`作为公共门面 (Public Facade)**: `index.ts` 是单元对外的**唯一公共接口**。它负责从单元内部的其他文件导入功能，进行组装，并最终导出稳定、统一的公共函数和类型。单元的内部实现细节（如`utils/`目录下的文件）**不应该**被单元外部直接导入。
    *   `types.ts`**作为类型中心**: 定义所有该单元对外暴露或内部复用的复杂类型与接口。

#### **2.2 Kernel 与 Module 的内部结构**

*   **职责**: 提供无状态、无副作用的函数工具箱。
*   **核心戒律**:
    *   **严禁 `effect.ts`**: `Kernel` 和 `Module` 的目录中**严禁**创建和使用 `effect.ts` 文件。
    *   **允许常量配置**: **可以**创建 `config.ts` 文件，但**必须**只导出编译时确定的只读常量 (`export const ...`)，用于消除魔法值。

#### **2.3 Service 的内部结构**

*   **职责**: 封装状态和副作用，提供业务能力。
*   **核心戒律**:
    *   **必须包含 `effect.ts`**: 所有与外部世界交互的“不纯”操作（数据库查询、API请求等）**必须**被封装在 `effect.ts` 文件中。
    *   **允许动态配置**: **可以**创建 `config.ts` 来定义需要从外部环境加载的运行时配置。这些配置**必须**在 `index.ts` 的工厂函数内部被加载，并成为服务状态的一部分。

#### **2.4 模块化与代码风格**

*   **模块系统**:
    *   **强制使用 ES Modules**: **必须**统一使用 `import`/`export` 进行模块管理。
    *   **推荐导出风格**: **应该**优先使用 `export const myFunction = () => {}` 风格的具名函数导出，以保持项目一致性。

*   **导入路径规范**:
    *   项目**必须**在 `tsconfig.json` 中配置路径别名 `{"@/*": ["src/*"]}`。
    *   **跨单元导入**: 当从一个单元（如 `user-service`）导入另一个单元（如 `auth-logic`）时，**必须**使用 `@` 别名创建的绝对路径。
        ```typescript
        // in: src/services/user-service/index.ts
        import { verifyToken } from '@/modules/auth-logic'; // ✅ Correct
        ```
    *   **单元内导入**: 在一个单元内部的文件之间导入时，**必须**使用相对路径。
        ```typescript
        // in: src/services/user-service/index.ts
        import { findUserInDb } from './effect'; // ✅ Correct
        import { User } from './types';         // ✅ Correct
        ```

*   **命名与格式化**:
    *   **命名**: 变量/函数 `camelCase`，类型/接口 `PascalCase`，常量 `UPPER_SNAKE_CASE`，目录/文件 `kebab-case`。
    *   **格式化**: 所有代码**必须**通过 Prettier 和 ESLint 格式化。

#### **2.5 代码抽象与文件规模**

为了保证代码的可读性、可维护性以及对 AI 的友好性，我们对代码的微观结构进行以下量化约束。

*   **逻辑复用**:
    *   任何重复出现超过 **两次** 的业务逻辑 **必须** 抽象并提炼成独立的、可复用的函数。

*   **文件与函数规模多维度约束**:
    *   **函数长度**: 建议单个函数的长度 **不超过 30 行**。
    *   **圈复杂度**: 建议单个函数的圈复杂度 **不超过 10**。
    *   **文件行数**: 建议单个文件的代码行数 **不超过 300 行**。

*   **例外机制**:
    *   对于复杂的算法实现、不可避免的模板代码或由工具生成的代码，若超出上述建议，**可以**在代码审查（Code Review）中提出并提供充分理由作为例外。其核心评判标准是：代码的复杂性是否是问题本身所固有的，而非不良结构导致的。

---

### **第三部分：专项工程实践**

#### **3.1 错误处理 (分层策略)**

*   **`Module` / `Kernel` 层**: **应该**返回一个可辨识联合类型（如 `Result<T, E>`），避免抛出异常。
*   **`Service` / `Main` 层**: **必须**使用 `try...catch` 来处理可预见的外部错误。对于程序逻辑错误，**必须**让其快速失败。

#### **3.2 测试 (分层策略)**

*   **`Kernel` 层**: **完备的单元测试** (覆盖率 ≈ 100%)。
*   **`Module` 层**: **纯粹的单元测试** (覆盖率 > 95%)，**严禁**使用 Mock。
*   **`Service` 层**: **集成测试**，**必须** Mock 掉所有外部依赖。
*   **`Main` 层**: **端到端 (E2E) 测试**。

#### **3.3 其他全局规范**

*   **性能优化哲学**:
    *   **禁止过早优化**: **严禁**任何未经性能分析证实的、牺牲代码清晰度的优化。
    *   **科学流程**: 优化**必须**遵循“测量 -> 分析 -> 优化 -> 验证”的流程。